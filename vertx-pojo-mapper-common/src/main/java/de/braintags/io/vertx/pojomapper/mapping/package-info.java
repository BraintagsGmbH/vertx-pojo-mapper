/*-
 * #%L
 * vertx-pojo-mapper-common
 * %%
 * Copyright (C) 2017 Braintags GmbH
 * %%
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * #L%
 */

/**
 * The mapping of vertx-pojo-mapper defines the bases and the rules on how POJOs are stored into and read from
 * the underlaying database and includes the automatic table creation and synchronization. The mapping process
 * in vertx-pojo-mapper is performed exactly then, when it is needed.
 * 
 * When you are creating an {@link de.braintags.io.vertx.pojomapper.dataaccess.query.IQuery} for instance, the system
 * checks, wether the mapper was initialized already. If not, then the initialization is performed, which implements
 * the automatic creation and update of tables, collections etc. inside the connected datastore - so you donâ€™t have
 * to care about that, either. Its this behaviour, why the vertx-pojo-mapper has only a very little overhead on startup!
 * 
 * During the mapping process the class is inspected for several information. The persistent fields of a mapper are
 * generated by inspecting public fields and BeanProperties. The rest of the configuration of a mapper is done by using
 * annotations. Annotations are always added to a field or the Class itself. Even annotations for those properties,
 * which are defined as getter / setter-method must be added to the underlaying field of the methods. For example mapper
 * definitions check the QuickStart.
 * 
 * ==== Mapper
 * The result of the mapping process is an {@link de.braintags.io.vertx.pojomapper.mapping.IMapper}, which is created by
 * and stored inside the {@link de.braintags.io.vertx.pojomapper.mapping.IMapperFactory} implementation, which fits the
 * needs of the underlaying datastore or database. The IMapper contains general information about the mapped class and
 * the generated, respectively connected table in the datastore. Additionally it contains per property of the mapper an
 * instance of {@link de.braintags.io.vertx.pojomapper.mapping.IField}, where the field and its behaviour regarding the
 * mapping are desribed. Additionally per field the information about the connected column inside the datastore are kept
 * inside an instance of {@link de.braintags.io.vertx.pojomapper.mapping.datastore.IColumnInfo}
 * 
 * ==== TableGenerator and ColumnHandler
 * As explained above, vertx-pojo-mapper is able to generate needed structures in the underlaying datastore, like tables
 * for sql databases. Base for the generation is the
 * {@link de.braintags.io.vertx.pojomapper.mapping.datastore.IColumnHandler}, from which the suitable instance is stored
 * inside the IField. The IColumnHandler is detected during the mapping process by requesting a suitable one from the
 * {@link de.braintags.io.vertx.pojomapper.mapping.datastore.ITableGenerator} used by a datastore implementation.
 * The process of creation and synchronization is performed by
 * {@link de.braintags.io.vertx.pojomapper.mapping.IDataStoreSynchronizer}
 *
 * @author Michael Remme
 */
package de.braintags.io.vertx.pojomapper.mapping;
