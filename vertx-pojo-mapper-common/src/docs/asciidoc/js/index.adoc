:numbered:
:toc: left
:toclevels: 3

= vertx pojo mapper common

Map Java objects into datastores and back

== Quick-Start
Although this library will deal with completely different types of datastores like SQL, NoSQL etc., we are using some
idioms inside the further description, which are more or less database depending.

Thus a "table" will refer to a
table inside a MySQL for instance and to a collection inside a MongoDB - just to avoid stringy text constructions.

=== Using vertx-pojo-mapper
To use this project, add the following dependency to the _dependencies_ section of your build descriptor:

* Maven (in your `pom.xml`):

[source,xml,subs="+attributes"]
----
<dependency>
  <groupId>de.braintags</groupId>
<artifactId>vertx-pojo-mapper-common</artifactId>
<version>1.4.0-SNAPSHOT</version>
</dependency>
----

* Gradle (in your `build.gradle` file):

[source,groovy,subs="+attributes"]
----
dependencies {
compile 'de.braintags:vertx-pojo-mapper-common:1.4.0-SNAPSHOT'
}
----


replace maven-artifactId against one of

* *vertx-pojongo* the mongo driver
* *vertx-pojo-mapper-mysql* the MySql driver


=== Initializing an IDataStore
The initialization of the `IDataStore` is the only action, where you are
directly referring to a concrete implementation. In this example we will use a Mongo-DB as datastore:

[source, java]
----
JsonObject config = new JsonObject();
config.put("connection_string", "mongodb://localhost:27017");
config.put("db_name", "PojongoTestDatabase");
MongoClient mongoClient = MongoClient.createNonShared(vertx, config);
MongoDataStore mongoDataStore = new MongoDataStore(vertx, mongoClient, config);
----
To initialize the datastore, we are first creating an instance of MongoClient from the vertx-mongo-client.
To create an instance we define the properties with the minimum definition connection_string and db_name, which
are defining the location of the running Mongo-DB and the database to be used.
With this MongoClient we are then able to create a MongoDataStore, which will be the base for all the followings.

==== Initialize by DataStoreSettings
In contrast to a programmatical initialization of an IDataStore, you may initialize it by using
`DataStoreSettings`, which you can simply store as
a local file.

[source, java]
----
try {
  DataStoreSettings settings = loadDataStoreSettings(vertx, "/some/path/to/settings.json");
  IDataStoreInit dsInit = settings.getDatastoreInit().newInstance();
  dsInit.initDataStore(vertx, settings, initResult -> {
    if (initResult.failed()) {
      logger.error("could not start mongo client", initResult.cause());
      handler.handle(Future.failedFuture(new InitException(initResult.cause())));
    } else {
      handler.handle(Future.succeededFuture(initResult.result()));
    }
  });
} catch (Exception e) {
  handler.handle(Future.failedFuture(e));
}
----
In this example first the `DataStoreSettings` are loaded from a local
file. Afterwards the `IDataStoreInit` is instantiated and then the
method IDataStoreInit#initDataStore is called.
This method uses the `getProperties` to create a
suitable IDataStore.
The properties, which can be set here, are depending from the implementation of IDataStoreInit, please refer to the
extensions for MySql and MongoDb, for instance.

<pre>
[source, java]
----
 public DataStoreSettings loadDataStoreSettings(String path) {
   FileSystem fs = vertx.fileSystem();
   if (fs.existsBlocking(path)) {
     Buffer buffer = fs.readFileBlocking(path);
     DataStoreSettings settings = Json.decodeValue(buffer.toString(), DataStoreSettings.class);
     return settings;
   } else {
     IDataStoreSettings settings = MongoDataStoreInit.createDefaultSettings();
     fs.writeFileBlocking(path, Buffer.buffer(Json.encode(settings)));
     throw new FileSystemException("File did not exist and was created new in path " + path);
   }
 }

----
</pre>

The above method loads the DataStoreSettings from the filesystem as Json format. If the file doesn't exist, the
default settings are created by requesting a static method of MongoDataStoreInit. After they are saved at the
expected location and an exeption is thrown, to force the user to edit them.

=== Creating a mapper
Creating a mapper is very simple:

[source, java]
----
@Source(translate = false)
@Entity
public class MiniMapper {

  public static final IIndexedField NAME = new IndexedField("name");

  @Id
  public String id;
  public String name;
  public int number;

  public MiniMapper() {
  }

}
----
As you can see, you can specify any java class as a mapper by adding two annotations:

* `@Entity`
is added at the class level and defines, that the class, where this annotation is added, is mappable by a datastore
* `@Id`
is added at one property field of the class and defines this field to be the key field, where inside the
identifyer of a record is generated and stored

[small]#don't bother about the upper annotation @Source, which is needed to generate this documentation
and has nothing to do with the mapping definition#

Instead of using public field, we could have defined the fields as private and added the suitable getter / setter
methods, but for this example its the shorter way.

=== Saving data into a datastore
First we are creating an instance like - lets say - instances are created in java?

[source,java]
----
DemoMapper demoMapper = new DemoMapper();
demoMapper.setName("my mini mapper");
----

Next we want to save this MiniMapper into the connected datastore.
[source,java]
----
IWrite<DemoMapper> write = dataStore.createWrite(DemoMapper.class);
write.add(demoMapper);
write.save(result -> {
  if (result.failed()) {
    logger.error(result.cause());
  } else {
    IWriteResult wr = result.result();
    IWriteEntry entry = wr.iterator().next();
    logger.info("written with id " + entry.getId());
    logger.info("written action: " + entry.getAction());
    logger.info("written as " + entry.getStoreObject());
  }
});
----

To save one or more instances inside the datastore, we are first creating an
`IWrite`. As soon as we added the instance
into the IWrite, we are able to execute the save action on it and therefore save our MiniMapper into the
connected datastore.
In return we are receiving information about the action performed in an asynchrone way. The
`IWriteResult`, which was delivered to our
handler contains general informations about the action and specific information about each object, which was
saved by the current action. These information - delivered as
`IWriteEntry` -
include the type of action performed ( insert / update ), the id
of the instance ( especially for new instances ) and the native format of the instance, like it was translated to fit
the requirements of the connected datastore.

NOTE: You may have noticed, that up to here we did not have to execute any intialization of the mapper inside the
datastore. This is, because the vertx-pojo-mapper is taking care about that completely automatic exactly then, when
it is
needed.
When you are creating an insert like above, or a query like later, the system checks, wether the mapper was
initialized already. If not, then the initialization is performed, which implements the automatic creation and update
of tables, collections etc. inside the connected datastore - so you don't have to care about that, either.
Its this behaviour, why the vertx-pojo-mapper has only a very little overhead on startup!


=== Searching data in a datastore

To search inside the connected datastore, we are creating first an instance of
`IQuery`, then we are adding the query arguments on it.

[source,java]
----
IQuery<DemoMapper> query = dataStore.createQuery(DemoMapper.class);
query.setSearchCondition(ISearchCondition.isEqual(DemoMapper.NAME, "my mini mapper"));
query.execute(rResult -> {
  if (rResult.failed()) {
    logger.error(rResult.cause());
  } else {
    IQueryResult<DemoMapper> qr = rResult.result();
    qr.iterator().next(itResult -> {
      if (itResult.failed()) {
        logger.error(itResult.cause());
      } else {
        DemoMapper readMapper = itResult.result();
        logger.info("Query found id " + readMapper.id);
      }
    });
  }
});
----

In the current example we are only searching for the name, but as IQuery supports a fluent api
we could simply and quickly add further arguments. Again - with the creation of the IQuery - the system checks wether
the mapper class was mapped already and performs the mapping if not. +
The query is processed by calling the execute method, which in turn will deliver an
`IQueryResult`. The IQueryResult contains several
information like the native query and a reference to found records. The found records can be requested step by step
by an Iterator or once as Array by requesting the method toArray.

NOTE: To return as fast as possible and to produce the least overhead, in the first step the query only stores the
native result of the query inside the IQueryResult together with some meta information. Only when you are accessing
concrete objects by using the iterator of the IQueryResult or the method toArray, the needed java objects are
created, if not done already.


=== Deleting data

To delete instanced from the datastore, we are using
`IDelete`, where
we can add some concrete objects to be deleted or add an
`IQuery`, which defines
the criteria for a deletion. Mixing both isn't possible.

[source,java]
----
IDelete<DemoMapper> delete = dataStore.createDelete(DemoMapper.class);
delete.add(mapper);
delete.delete(deleteResult -> {
  if (deleteResult.failed()) {
    logger.error("", deleteResult.cause());
  } else {
    logger.info(deleteResult.result().getOriginalCommand());
  }
});
----

In the current example we are deleting an object, which we are expecting to exist in the datastore. First we are
creating an `IDelete` and add the instance to be deleted.
The execution of the delete is processed by calling the method delete, which will return an instance of
`IDeleteResult`. The method
`getOriginalCommand` returns the native
arguments which were used to perform the delete action

[source,java]
----
IQuery<DemoMapper> query = dataStore.createQuery(DemoMapper.class);
query.setSearchCondition(ISearchCondition.isEqual(DemoMapper.NAME, "test"));
IDelete<DemoMapper> delete = dataStore.createDelete(DemoMapper.class);
delete.setQuery(query);
delete.delete(deleteResult -> {
  if (deleteResult.failed()) {
    logger.error("", deleteResult.cause());
  } else {
    logger.info(deleteResult.result().getOriginalCommand());
  }
});
----

This example shows how to perform a delete action by using an
`IQuery`.
All records, which are fitting the arguments of the query are deleted.

=== Executing native, database specific commands
If the facilities of vertx-pojo-mapper aren't enough, you are able to execute native commands directly in two ways:

==== Using the internal driver
The method `getClient` returns the internall client, which is
used to communicate with the database. Casting this to the correct Class will allow you to send native commands in
any form to the database and deal with the native format, like in the example here for a MongoDb:

<pre>
[source,java]
----
 MongoClient client = (MongoClient) datastore.getClient();
 JsonObject insertCommand = new JsonObject();
 insertCommand.put("name", "testName");
 client.insert("TestCollection", insertCommand, result -> {
   if (result.failed()) {
     logger.error("", result.cause());
   } else {
     logger.info("executed: " + result.result());
   }
 });
----
</pre>

==== Using IQuery for a native command
The method `setNativeCommand` allows you to
define
an object with a native, database specific query expression. If this argument is passed and the IQuery is executed,
then the system will use this command to perform the query and will transform the result into instances of the
defined mapper.
In the example below we are performing a native execution for MySqlDataStore:


[source, java]
----
IQuery<MiniMapper> query = datastore.createQuery(MiniMapper.class);
String qs = "select * from MiniMapper where name LIKE \"native%\"";
query.setNativeCommand(qs);
query.execute(qr -> {
if (qr.succeeded()) {
IteratorAsync<MiniMapper> it = qr.result().iterator();
while (it.hasNext()) {
...
}
}
});

----

=== The observer system
An application, which uses jomnigate, may be registered to react to several events, which are suppported by
jomnigate.

IObserver is the instance, which can be used to register to those events and to extend jomnigate in a
comprehensive way for writing audit logs, checking data permissions, performing data versioning etc.
Observers can be executed as fire-and-forget, or the caller is waiting for the execution.

The registration of observers can be done:

* globally by DatastoreSettings.observerSettings
a definition can be something like "execute observer myObserver.class for all events of type afterSave", "execute
observer myObserver.class for all events for all instances of IAuditable.class", "execute observer myObserver.class
with priority 500 for events afterSave, afterDelete for all instances with the annotation Auditable.class"

* per annotation inside a mapper definition
the annotation `@Observer` as class annotation defines the events to be
executed, the observer class and the priority

An observer can be any class, which implements IObserver. An observer receives informations about the event, the
instance to be handled and an ObserverContext, which is created at the beginning of an action inside jomnigate. The
observer normally returns a Future, where the caller is waiting for. If it returs null, then the observer is executed
as fire-and-forget.


[source, json]
----

{
  "datastoreInit": "de.braintags.vertx.jomnigate.mongo.init.MongoDataStoreInit",
  "properties": {
    "startMongoLocal": "true",
    "handleReferencedRecursive": "true",
    "localPort": "27017",
    "connection_string": "mongodb://localhost:27017",
    "shared": "false",
    "defaultKeyGenerator": "DefaultKeyGenerator"
  },
  "databaseName": "UnitTestDatabase",
  "encoders": [
    {
      "name": "StandardEncoder",
      "encoderClass": "de.braintags.vertx.util.security.crypt.impl.StandardEncoder",
      "properties": {
        "salt": "0F06BFA0BF70A46BB9E39121904DC402684543E4B152464D6FAD4324A15BAAED"
      }
    }
  ],
  "clearDatabaseOnInit": false,
  "observerSettings": [
    {
      "observerClass": "de.braintags.vertx.jomnigate.testdatastore.observer.TestObserver",
      "eventTypeList": [],
      "mapperSettings": [],
      "priority": 500
    },
    {
      "observerClass": "de.braintags.vertx.jomnigate.testdatastore.observer.TestObserver2",
      "eventTypeList": [],
      "mapperSettings": [],
      "priority": 200
    },
    {
      "observerClass": "de.braintags.vertx.jomnigate.testdatastore.observer.TestObserver3",
      "eventTypeList": [],
      "mapperSettings": [],
      "priority": 501
    }
  ]
}


----


=== Complexer mapper definitions

The example above was very simple and straightforward, just to explain the basics of vertx-pojo-mapper. But of course
there are
existing much more possibilities to define mappers, where from we are listing some here ( the complete list of
annotations you will find below).

==== Handling of subobjects
Often you will have to define some mappers, where inside you are placing one or more properties, which are not of a
simple type like int, String, boolean etc., but which are based upon a complexer type. Think about a scenario, where
a person has one or more animals. +
For those relations you can define two ways, how the data are stored into the datastore:

* embedded +
the subobjects ( animals ) are stored inside the same table than the main object ( person )
* referenced +
the subobjects ( animals ) are saved inside an own table; inside the main object ( person ) is saved a reference to
the subobjects, typically the key of the subobjects

===== Storing subobjects embedded

To define, that a subobject shall be saved embedded is simply done by adding the annotation
`@Embedded` to the appropriate field

[source,java]
----
@Source(translate = false)
@Entity
public class PersonEmbed {
  @Id
  public String id;
  public String name;
  @Embedded
  public Animal animal;

  public PersonEmbed() {
  }

}
----

How the embedding is technically processed, is decided by the `IDataStore`. In
the same way you are storing simple child objects, you are able to integrate lists, maps and arrays.

Subobjects as array of Animal:

[source,java]
----
@Source(translate = false)
@Entity
public class PersonEmbedArray {
  @Id
  public String id;
  public String name;
  @Embedded
  public Animal[] animals;

  public PersonEmbedArray() {
  }

}
----

Subobjects as List of Animal:

[source,java]
----
@Source(translate = false)
@Entity
public class PersonEmbedList {
  @Id
  public String id;
  public String name;
  @Embedded
  public List<Animal> animals;

  public PersonEmbedList() {
  }

}
----

Subobjects as Map of Animal:

[source,java]
----
@Source(translate = false)
@Entity
public class PersonEmbedMap {
  @Id
  public String id;
  public String name;
  @Embedded
  public Map<String, Animal> animals;

  public PersonEmbedMap() {
  }

}
----

===== Storing subobjects referenced

According the previous description, storing subobjects referenced is done by adding the annotation
`@Referenced` to the appropriate fields of the
mapper. Of course here, too, you are able to store lists, maps and arrays either.

[source,java]
----
@Source(translate = false)
@Entity
public class PersonRef {
  @Id
  public String id;
  public String name;
  @Referenced
  public Animal animal;

  public PersonRef() {
  }

}
----


==== Lifecycle methods

In vertx-pojo-mapper are existing a series of lifecycle annotations, by which you can modify the content
of objects as a function of its lifecycle. If you are annotating one or more methods of a mapper class with
one of the lifecycle annotations, then those method(s) are executed inside the suitable situation

[source,java]
----
@Source(translate = false)
@Entity
public class LifecycleMapper {
  @Id
  public String id;
  public String name;

  public LifecycleMapper() {
  }

  @BeforeLoad
  public void beforeLoad() {
    name = "just before load";
  }

  @AfterLoad
  public void afterLoad(ITriggerContext triggerContext) {
    name = "just after load";
    IDataStore ds = triggerContext.getMapper().getMapperFactory().getDataStore();
    IQuery<MiniMapper> q = ds.createQuery(MiniMapper.class);
    q.setSearchCondition(ISearchCondition.isEqual(MiniMapper.NAME, "test"));
    q.execute(qr -> {
      if (qr.failed()) {
        triggerContext.fail(qr.cause());
      } else {
        // do something
        triggerContext.complete();
      }
    });
  }

  @BeforeSave
  public void beforeSave() {
    name = "just before save";
  }

  @AfterSave
  public void afterSave() {
    name = "just after save";
  }

  @BeforeDelete
  public void beforeDelete() {
    name = "just before deletion";
  }

  @AfterDelete
  public void afterDelete() {
    name = "just after deletion";
  }

}
----

Currently are existing 6 lifecycle annotations

* `@BeforeSave` +
methods annotated with this, will be executed just before saving an instance into the datastore
* `@AfterSave` +
methods annotated with this, will be executed just after saving an instance into the datastore
* `@BeforeLoad` +
methods annotated with this, will be executed just before loading an instance from the datastore
* `@AfterLoad` +
methods annotated with this, will be executed just after loading an instance from the datastore
* `@BeforeDelete` +
methods annotated with this, will be executed just before deleting an instance from the datastore
* `@AfterDelete` +
methods annotated with this, will be executed just after deleting an instance from the datastore

The trigger methods can be empty, or get the parameter
`ITriggerContext`, by which you are able to access the current
`IDataStore` for instance, like shown in the example method afterLoad

[source,java]
----
name = "just after load";
IDataStore ds = triggerContext.getMapper().getMapperFactory().getDataStore();
IQuery<MiniMapper> q = ds.createQuery(MiniMapper.class);
q.setSearchCondition(ISearchCondition.isEqual(MiniMapper.NAME, "test"));
q.execute(qr -> {
  if (qr.failed()) {
    triggerContext.fail(qr.cause());
  } else {
    // do something
    triggerContext.complete();
  }
});
----

==== Encryption
By using the annotation `@Encoder` you can encrypt field
contents like passwords for instance.

[source,java]
----
@Source(translate = false)
@Entity
public class MiniMapperEncoded {
  @Id
  public String id;
  public String name;
  public int number;
  @Encoder(name = "StandardEncoder")
  public String password;

  public MiniMapperEncoded() {
  }

}
----

In the above example the field password is annotated with
`@Encoder`, which is getting the name of the encoder as
reference. Each datastore integrates one decoder by default,
`StandardEncoder` with the name StandardEncoder, which we are
referencing here. If you want to add another encoder, you can do that by modifying the
`DataStoreSettings` by adding an instance of
`EncoderSettings`

=== Working with geodata
Specification of datatypes following the GeoJSON spec from http://geojson.org/
Searching and saving geodata following the GeoJSON spec

tbd
Michael Remme


For more infos on how you can influence the mapping process, see the further descriptions above.

== More details about vertx-pojo-mapper

=== IDataStore
`IDataStore` is the startpoint and the center of vertx-pojo-mapper.
By IDataStore you will access all the main instances you need, to deal with the underlaying datastore.
To instantiate a certain implementation of IDataStore, it should be the only time, where you are directly referencing
to a certain datastore or database. The way, how an implementation is instantiated, is depending on the
implementation itself:

Currently there are existing 2 implementations of IDataStore

* MongoDataStore +
in the sub project link:https://github.com/BraintagsGmbH/vertx-pojo-mapper/tree/master/vertx-pojongo[vertx-pojongo],
is an implementation which deals with Mongo-DB. Go
link:https://github.com/BraintagsGmbH/vertx-pojo-mapper/tree/master/vertx-pojongo[here] to get more informations on
how to create an instance of MongoDataStore
* MySqlDataStore +
in the sub project
link:https://github.com/BraintagsGmbH/vertx-pojo-mapper/tree/master/vertx-pojo-mapper-mysql[vertx-pojo-mapper-mysql]
is an implementation which deals with MySql or MariaDb. Go
link:https://github.com/BraintagsGmbH/vertx-pojo-mapper/tree/master/vertx-pojo-mapper-mysql[here] to get more
information on how to create an instance of MySqlDataStore
* more implementations will follow soon

Where by using the links above you will get some specific information how to initialize one of those implementations,
in the following parts we will go into the detail for some concepts of the api.

=== KeyGenerator

If you are inserting new records into a database, those records normally need to get a unique identifyer, typically a
primary key. All databases can generate such a key in an automatic manner, but not every database is returning the
generated key. For those databases, which don't return the generated key, like MySql, the concept of
`IKeyGenerator` was implemented to allow a key generation with local
access before a new instance is saved into the datastore. Another use case is, when the datastore itself creates a
cryptic ID and a numeric one is needed +
The config below defines a default datastore, which is used for all mappers, where no KeyGenerator is defined.

[source,java]
----
JsonObject datastoreConfig = new JsonObject().put("database", database)
.put(IKeyGenerator.DEFAULT_KEY_GENERATOR, FileKeyGenerator.NAME);
IDataStore datastore = new MySqlDataStore(vertx, mySQLClient, mySQLClientConfig);
...
----

To add an IKeyGenerator to a mapper, you will add the annotation
`@KeyGenerator` to the classes head and optionally define the type
of keygenerator, which shall be used.

Currently there are existing three implementations of `IKeyGenerator`:

* `DefaultKeyGenerator` +
an implementation which uses the eventbus to request a key from
`KeyGeneratorVerticle`. To init and launch the KeyGeneratorVerticle, please
refer to the doscumentation of the project
link:https://github.com/BraintagsGmbH/vertx-key-generator/blob/master/src/docs/asciidoc/java/index.adoc[*vertx-key-
generator*]

* `DebugGenerator` +
a local implementation which starts at zero by each launch and maybe useful for unint tests etc.

* NULL as a special solution +
use `link:todo[KeyGenerator.NULL_KEY_GENERATOR]` as value to define, that no
keygenerator shall be used. This value is useful, when a default keygenerator is set and a certain class shal not use
one.

An `IDataStore` implementation might contain a set of
`IKeyGenerator`, which are supported by this implementation.
KeyGenerators are stored inside a map by their name and an instance. When initializing an
`IDataStore` you can add the property
`link:todo[IKeyGenerator.DEFAULT_KEY_GENERATOR]` together
with the name of the KeyGenerator, which shall be used as default. Additionally you can add the annotation
`@KeyGenerator` to a mapper, where you are specifying the name of
the KeyGenerator, which shall be used for this mapper.

=== Mapping of Java classes
The mapping of vertx-pojo-mapper defines the bases and the rules on how POJOs are stored into and read from
the underlaying database and includes the automatic table creation and synchronization.

The mapping process
in vertx-pojo-mapper is performed exactly then, when it is needed.

When you are creating an `IQuery` for instance, the system
checks, wether the mapper was initialized already. If not, then the initialization is performed, which implements
the automatic creation and update of tables, collections etc. inside the connected datastore - so you don’t have
to care about that, either. Its this behaviour, why the vertx-pojo-mapper has only a very little overhead on startup!

During the mapping process the class is inspected for several information. The persistent fields of a mapper are
generated by inspecting public fields and BeanProperties. The rest of the configuration of a mapper is done by using
annotations. Annotations are always added to a field or the Class itself. Even annotations for those properties,
which are defined as getter / setter-method must be added to the underlaying field of the methods. For example mapper
definitions check the QuickStart.

==== Mapper
The result of the mapping process is an `IMapper`, which is created by
and stored inside the `IMapperFactory` implementation, which fits the
needs of the underlaying datastore or database. The IMapper contains general information about the mapped class and
the generated, respectively connected table in the datastore. Additionally it contains per property of the mapper an
instance of `IProperty`, where the field and its behaviour regarding the
mapping are desribed. Additionally per field the information about the connected column inside the datastore are kept
inside an instance of `IColumnInfo`

==== TableGenerator and ColumnHandler
As explained above, vertx-pojo-mapper is able to generate needed structures in the underlaying datastore, like tables
for sql databases. Base for the generation is the
`IColumnHandler`, from which the suitable instance is stored
inside the IField. The IColumnHandler is detected during the mapping process by requesting a suitable one from the
`ITableGenerator` used by a datastore implementation.
The process of creation and synchronization is performed by
`IDataStoreSynchronizer`
Michael Remme

=== TypeHandlers
When objects shall be stored into or read from a datastore, the values must be converted in many
cases.

This is the job of an `ITypeHandler`. During the mapping of
a mapper property the suitable ITypeHandler is detected by requesting the
`ITypeHandlerFactory` of the underlaying
`IDataStore`. The found ITypeHandler is stored inside the appropriate
`IProperty` and from there used, when a value is read from or shall be
written into the datastore.
Michael Remme

=== Existing annotations
AS explained above, the definition of the mapping is currently done by using annotations, which are added to class
header of the pojo or to the single properties, to define the behavior of this class in terms of mapping.

Existing annotations are:

===== `@Entity`

( name = "tableName" ) +
The annotation `@Entity` defines a POJO to be mappable.
Additionally you are able to set the name of the table, which is used to store the information in the
`IDataStore`. By default the system will use the short classname of the
mapper.

===== `@Id`

One field of the mapper must be annotated by `@Id`, which
will mark the annotated field as primary key

===== `@Property`

Properties of a mapper are stored inside the `IDataStore` by using the
field name by default. By annotating a field with the annotation Property, you are able to modify the name of the
column in the table. Additionally you are able to define other attributes, which are very datastore specific, so you
should use them never or only very carefully:

===== `@Referenced`

When you define a mapper, which internally references with one property to another mapper ( see example Person and
his animals ), then you can define the way, how subobjects are stored inside the datastore. With this annotation you
define, that the subobjects are stored inside a separate table, and in the field itself only a reference - typically
the identifier - is saved. When reading the instance then from the datastore, the references are resolved
automatically.

===== `@Embedded`
The counterpart to `@Referenced`. A property, which is marked
with this annotation will be saved completely inside the table. How this is done, is decided by the implementation of
the `IDataStore` you are using.

===== `@ObjectFactory`

By default the `IObjectFactory` is defined inside each
`IMapper` by using a default implementation. If you need another
implementation you are able to set it by adding this annotation to the mapper class and reference the class of the
`IObjectFactory` you want to use.


===== `@Observer`
The annotation Observer is used to define an `IObserver`, which shall be
executed for a certain mapper. The annotation extends the possible globale definition of
`getObserverSettings`

===== `@AfterLoad`

All methods, which are annotated by this annotation are executed after an instance was loaded from the
`IDataStore`

===== `@BeforeLoad`

All methods, which are annotated by this annotation are executed before an instance is loaded from the
`IDataStore`. That means, first the new instance is created, then the
method is executed and then the data are transferred into the instance

===== `@AfterSave`

All methods, which are annotated by this annotation are executed after an instance was saved into the
`IDataStore`

===== `@BeforeSave`

All methods, which are annotated by this annotation are executed before an instance is saved into the
`IDataStore`

===== `@AfterDelete`

All methods, which are annotated by this annotation are executed after an instance was deleted from the
`IDataStore`

===== `@BeforeDelete`

All methods, which are annotated by this annotation are executed before an instance is deleted from the
`IDataStore`


===== `@KeyGenerator`
With this annotation you may define the `IKeyGenerator`, which shall
be used for the mapper. Normally the IKeyGenerator is used, which is defined as default by
`getDefaultKeyGenerator`, which should be normally
`DefaultKeyGenerator`. As a value for this annotation you
are defining the name of the IKeyGenerator, which shall be used

[source, java]
----
@Source(translate = false)
@Entity
@KeyGenerator
public class KeyGeneratorMapper {
  @Id
  public String id;

}
----

== Creating a new implementation

tbd

== Further links
To get specific information about the concrete implementation of an
`IDataStore`, especially the initialization, go to:

* link:https://github.com/BraintagsGmbH/vertx-pojo-mapper/tree/master/vertx-pojo-mapper-mysql[implementation for
MySql]
* link:https://github.com/BraintagsGmbH/vertx-pojo-mapper/tree/master/vertx-pojongo[implementation for Mongo-DB]