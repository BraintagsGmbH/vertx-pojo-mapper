/*
 * #%L
 * vertx-pojo-mapper-common-test
 * %%
 * Copyright (C) 2017 Braintags GmbH
 * %%
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * #L%
 */
package de.braintags.vertx.jomnigate.testdatastore;

import org.junit.Test;

import de.braintags.vertx.jomnigate.mapping.IKeyGenerator;
import de.braintags.vertx.jomnigate.mapping.IMapper;
import de.braintags.vertx.jomnigate.mapping.IStoreObject;
import de.braintags.vertx.jomnigate.mapping.IStoreObjectFactory;
import de.braintags.vertx.jomnigate.mapping.impl.keygen.DefaultKeyGenerator;
import de.braintags.vertx.jomnigate.testdatastore.mapper.KeyGeneratorMapper;
import de.braintags.vertx.jomnigate.testdatastore.mapper.NoKeyGeneratorMapper;
import de.braintags.vertx.util.ResultObject;
import io.vertx.ext.unit.Async;
import io.vertx.ext.unit.TestContext;

/**
 * 
 * 
 * @author Michael Remme
 * 
 */

@SuppressWarnings({ "unchecked", "rawtypes" })
public class TestStoreObject extends DatastoreBaseTest {
  private static final io.vertx.core.logging.Logger LOGGER = io.vertx.core.logging.LoggerFactory
      .getLogger(TestStoreObject.class);

  @Test
  public void testStoreObject(TestContext context) {
    IStoreObjectFactory stof = getDataStore(context).getStoreObjectFactory();
    NoKeyGeneratorMapper entity = new NoKeyGeneratorMapper();
    IMapper mapper = getDataStore(context).getMapperFactory().getMapper(entity.getClass());
    try {
      stof.createStoreObject((Object) null, mapper, res -> {
        LOGGER.debug("test");
      });
    } catch (NullPointerException e) {
      LOGGER.debug("Expected exception gained", e);
    }

    try {
      stof.createStoreObject((IMapper) null, entity, res -> {
        LOGGER.debug("test");
      });
    } catch (NullPointerException e) {
      LOGGER.debug("Expected exception gained", e);
    }

    // stof.createStoreObject(mapper, entity, context.asyncAssertSuccess(res -> {
    // LOGGER.debug(res.getClass().getName());
    // AbstractStoreObject sto = (AbstractStoreObject) res;
    // sto.initFromEntity(context.asyncAssertSuccess(res2 -> {
    //
    // }));
    // }));

    // stof.createStoreObjects(mapper, entities, handler);
  }

  /*
   * 
   * context.asyncAssertFailure(res -> {
   * LOGGER.debug("", res);
   * })
   */

  @Test
  public void testWithNullKeyGenerator(TestContext context) {
    NoKeyGeneratorMapper entity = new NoKeyGeneratorMapper();
    IMapper mapper = getDataStore(context).getMapperFactory().getMapper(entity.getClass());
    IKeyGenerator keyGen = mapper.getKeyGenerator();
    context.assertNull(keyGen, "keyGenerator must be null but is instance of " + String.valueOf(keyGen));

    entity.name = "testName";
    IStoreObject<?, ?> sto = createStoreObject(context, mapper, entity);
    if (getDataStore(context).getClass().getName().contains("Mongo")) {
      Object idValue = sto.get(mapper.getIdInfo().getField());
      context.assertNull(idValue, "id must be null here: " + idValue);
      boolean hp = sto.hasProperty(mapper.getIdInfo().getField());
      context.assertFalse(hp, "id-property should not exist here");
    } else {
      // mySQL creates ID later, not with StoreObject
    }
  }

  @Test
  public void testWithKeyGenerator(TestContext context) {
    KeyGeneratorMapper entity = new KeyGeneratorMapper();
    IMapper mapper = getDataStore(context).getMapperFactory().getMapper(entity.getClass());
    IKeyGenerator keyGen = mapper.getKeyGenerator();
    context.assertTrue(keyGen.getClass() == DefaultKeyGenerator.class,
        "keygenerator should be " + DefaultKeyGenerator.class.getName() + " but is " + keyGen.getClass().getName());
    entity.name = "testName";
    IStoreObject<?, ?> sto = createStoreObject(context, mapper, entity);
    if (getDataStore(context).getClass().getName().contains("Mongo")) {
      Object idValue = sto.get(mapper.getIdInfo().getField());
      context.assertNotNull(idValue, "id value should have been generated by KeyGenerator locally: " + idValue);
      // should be a numeric value
      Integer.parseInt(String.valueOf(idValue));
    } else {
      // mySQL creates ID later, not with StoreObject
    }
  }

  @SuppressWarnings("unchecked")
  private IStoreObject<?, ?> createStoreObject(TestContext context, IMapper mapper, Object entity) {
    Async async = context.async();
    ResultObject<IStoreObject<?, ?>> ro = new ResultObject<>(null);
    IStoreObjectFactory<?> f = TestHelper.getDataStore().getStoreObjectFactory();
    f.createStoreObject(mapper, entity, result -> {
      if (result.failed()) {
        ro.setThrowable(result.cause());
      } else {
        ro.setResult(result.result());
      }
      async.complete();
    });
    async.await();
    if (ro.isError()) {
      throw ro.getRuntimeException();
    } else {
      return ro.getResult();
    }
  }
}
